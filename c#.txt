问题：vs2010 宏不生效
解决：
	1.C:\Program Files (x86)\Common Files\microsoft shared\VSA\9.0\VsaEnv\vsmsvr10.exe.config
	2.runtime 标签内添加 <AllowDComReflection enabled="1"/>
	3.重启 vs 生效
获取显示器分辨率大小
	// 屏幕-主屏幕-WorkingArea（不包括工具栏）-包络线-宽
	System.Windows.Forms.Screen.PrimaryScreen.WorkingArea.Size.Width
设置窗体位置
	SetDesktopLocation(int x, int y);
类型转换
	字符串转数值
		int.Parse("1")
		int.Parse("1s") // 报错
		int.Parse("1.5") // 报错
		int fid;
		// 成功返回：true，失败返回：false
	    int.TryParse(textBox1.Text, out fid);
类
	10.属性
		9.自动实现属性
			1.没有后备字段
			2.访问器的方法体为空
	对象初始化列表
		MyClass instance = new MyClass(){age=10,name="Lily"}
	析构函数
		实例不再使用之后某个时间点执行
			函数前带波浪线
			一个类只有一个
			没参数、修饰符
				class MyClass{
					~func(){}
				}
	readonly和const区别：const 必须初始化
	17.索引
		可以重载
		class MyClass{
			int a=11;
			int b=22;
			int c=33;
			public num(int i)
			{
				get
				{
					switch(i)
					{
						case 0;return a;
						case 1:return b;
						case 2:return c;
					}
				}
				set
				{
					switch(i)
					{
						case 0;a=value;return;
						case 1:b=value;return;
						case 2:c=value;return;
					}
				}
			}
		}
	19.分部类和分部方法
		partial
7.类和继承
	4.屏蔽基类的成员
		1.声明相同的名称的成员，类型也相同
		2.函数成员签名相同，返回类型可以不同
		3.使用 new 修饰符 可以去除编译警告
		4.可以屏蔽静态成员
	5.基类访问
		访问被隐藏的基类成员：关键字 base.+成员名称
	6.使用基类的引用
		基类：virtual
		派生类：override
		虚方法可以使基类的引用访问转至派生类内
	7.构造函数的执行
		class Driver
		{
			// 构造函数实际执行：public son():base()
			public son():this("param")
			{}
			public son(string param)
			{}
		}
		new Driver();
		构造函数执行顺序：父类->子类带参数->子类无参数；由外往内
	8.类的访问修饰符
		不同命名空间下的类的可访问性
		public：不同命名空间可直接访问
		internal：默认
			1.使用 using 引用命名空间
			1.直接使用命名空间：myNamespace.MyClass
	9.成员的访问修饰符
		public
		private
		protected
		internal
		internal protected
19.泛型
	19.13　泛型的协变和逆变？
20.枚举数和迭代器
	1.枚举数和可枚举类型
		1.1　使用foreach语句
			obj.GetEnumerator(); 获取对象的枚举数
		1.2　枚举数类型
	2　使用IEnumerator接口
		Current 字段，返回当前位置元素
		MoveNext 方法，位置+1，新的位置无效返回 false
		Reset 重置位置为 -1
	3　IEnumerable接口
	4　不实现接口的枚举数
	5　泛型枚举接口
	6　IEnumerator接口
	7　IEnumerable接口
	8　迭代器
		8.1　迭代器块
		8.2　使用迭代器来创建枚举数
		8.3　使用迭代器来创建可枚举类型
	9　常见迭代器模式
	10　产生可枚举类型和枚举数
	11　产生多个可枚举类型
	12　产生多个枚举数
	13　迭代器实质
21.LINQ

补充
	类型转换
	字符串方法
	数组方法
	[]和 ArrayList
	日期 DateTime
		// 当前日期对象
		DateTime date = DateTime.Now;
		// 时间字符串
        DateTime date = DateTime.Parse("2018-05-15");
		DateTime.TryParse()
        // 时间戳
        DateTime date = DateTime.FromFileTime(45644646);
        // 只有年月日，时间为 0
		DateTime date = DateTime.Today
		输出格式
			
	Math
	定时器
		System.Threading.Timer
			// state 作为 cb 的参数，null
			// dueTime 首次执行等待时间
			// period 等待时间，如果是 0，只执行一次 
			public Timer(cb, object state, int dueTime, int period);
	        public Timer(cb, object state, long dueTime, long period);
	        public Timer(cb, object state, TimeSpan dueTime, TimeSpan period);
	        public Timer((cb, object state, uint dueTime, uint period);
	        	Dispose() ： 销毁
	        	bool Change(int dueTime, int period): 修改
	DataTable
		添加引用
			using System.Data;
		创建表
			//创建一个空表
			DataTable dt = new DataTable();
			//创建一个名为"Table_New"的空表
			DataTable dt = new DataTable("Table_New");
		创建列
			//1.创建空列
			DataColumn dc = new DataColumn();
			dt.Columns.Add(dc);
			//2.创建带列名和类型名的列(两种方式任选其一)
			dt.Columns.Add("column0", System.Type.GetType("System.String"));
			dt.Columns.Add("column0", typeof(String));
			//3.通过列架构添加列
			DataColumn dc = new DataColumn("column1",System.Type.GetType("System.DateTime"));
			DataColumn dc = new DataColumn("column1", typeof(DateTime));
			dt.Columns.Add(dc);
		创建行
			//1.创建空行
			DataRow dr = dt.NewRow();
			dt.Rows.Add(dr);
			//2.创建空行
			dt.Rows.Add();
			//3.通过行框架创建并赋值
			//Add里面参数的数据顺序要和dt中的列的顺序对应 
			dt.Rows.Add("张三",DateTime.Now);
			//4.通过复制dt2表的某一行来创建
			dt.Rows.Add(dt2.Rows[i].ItemArray);
		赋值和取值
			//新建行的赋值
			DataRow dr = dt.NewRow();
			dr[0] = "张三";//通过索引赋值
			dr["column1"] = DateTime.Now; //通过名称赋值
			//对表已有行进行赋值
			dt.Rows[0][0] = "张三"; //通过索引赋值
			dt.Rows[0]["column1"] = DateTime.Now;//通过名称赋值
			//取值
			string name=dt.Rows[0][0].ToString();
			string time=dt.Rows[0]["column1"].ToString();
		筛选行
			//选择column1列值为空的行的集合
			DataRow[] drs = dt.Select("column1 is null");
			//选择column0列值为"李四"的行的集合
			DataRow[] drs = dt.Select("column0 = '李四'");
			//筛选column0列值中有"张"的行的集合(模糊查询)
			//如果的多条件筛选，可以加 and 或 or
			DataRow[] drs = dt.Select("column0 like '张%'");
			//筛选column0列值中有"张"的行的集合并按column1降序排序
			DataRow[] drs = dt.Select("column0 like '张%'", "column1 DESC");
		删除行
			//使用DataTable.Rows.Remove(DataRow)方法
			dt.Rows.Remove(dt.Rows[0]);
			//使用DataTable.Rows.RemoveAt(index)方法
			dt.Rows.RemoveAt(0);
			//使用DataRow.Delete()方法
			dt.Row[0].Delete();
			dt.AcceptChanges();
			//-----区别和注意点-----
			//Remove()和RemoveAt()方法是直接删除
			//Delete()方法只是将该行标记为deleted，但是还存在，还可DataTable.RejectChanges()回滚，使该行取消删除。
			//用Rows.Count来获取行数时，还是删除之前的行数，需要使用DataTable.AcceptChanges()方法来提交修改。
			//如果要删除DataTable中的多行，应该采用倒序循环DataTable.Rows，而且不能用foreach进行循环删除，因为正序删除时索引会发生变化，程式发生异常，很难预料后果。
			for (int i = dt.Rows.Count - 1; i >= 0; i--)
			{
			　　dt.Rows.RemoveAt(i);
			}
		复制表
			//复制表，同时复制了表结构和表中的数据
			DataTable dtNew = new DataTable();
			dtNew = dt.Copy();
			//复制表
			DataTable dtNew = dt.Copy();  //复制dt表数据结构
			dtNew.Clear()  //清空数据
			for (int i = 0; i < dt.Rows.Count; i++)
			{
			    if (条件语句)
			    {
			         dtNew.Rows.Add(dt.Rows[i].ItemArray);  //添加数据行
			    }
			}
			//克隆表，只是复制了表结构，不包括数据
			DataTable dtNew = new DataTable();
			dtNew = dt.Clone();
			//如果只需要某个表中的某一行
			DataTable dtNew = new DataTable();
			dtNew = dt.Copy();
			dtNew.Rows.Clear();//清空表数据
			dtNew.ImportRow(dt.Rows[0]);//这是加入的是第一行

	正则
		e.g
			using System.Text.RegularExpressions;
			Regex reg=new Regex("filter",RegexOptions.IgnoreCase);
			if (reg.IsMatch(str))
	        {}
	dll
	addIn
	Random 生成随机数
		Random rand = new Random();
		// 随机非负整数 [0,15)
		rand.Next(15);
		// 随机整数 [-5,10)
		rand.Next(-5,10);
		// 随机小数 [0.0,1.0)
		rand.NextDouble
	comboBox 
		属性：
			SelectedIndex：0
			SelectedItem：someStr
			SelectedText：
			SelectedValue：