问题：vs2010 宏不生效
解决：
	1.C:\Program Files (x86)\Common Files\microsoft shared\VSA\9.0\VsaEnv\vsmsvr10.exe.config
	2.runtime 标签内添加 <AllowDComReflection enabled="1"/>
	3.重启 vs 生效
获取显示器分辨率大小
	// 屏幕-主屏幕-WorkingArea（不包括工具栏）-包络线-宽
	System.Windows.Forms.Screen.PrimaryScreen.WorkingArea.Size.Width
设置窗体位置
	SetDesktopLocation(int x, int y);
类型转换
	字符串转数值
		int.Parse("1")
		int.Parse("1s") // 报错
		int.Parse("1.5") // 报错
		int fid;
		// 成功返回：true，失败返回：false
	    int.TryParse(textBox1.Text, out fid);
类
	10.属性
		9.自动实现属性
			1.没有后备字段
			2.访问器的方法体为空
	对象初始化列表
		MyClass instance = new MyClass(){age=10,name="Lily"}
	析构函数
		实例不再使用之后某个时间点执行
			函数前带波浪线
			一个类只有一个
			没参数、修饰符
				class MyClass{
					~func(){}
				}
	readonly和const区别：const 必须初始化
	17.索引
		可以重载
		class MyClass{
			int a=11;
			int b=22;
			int c=33;
			public num(int i)
			{
				get
				{
					switch(i)
					{
						case 0;return a;
						case 1:return b;
						case 2:return c;
					}
				}
				set
				{
					switch(i)
					{
						case 0;a=value;return;
						case 1:b=value;return;
						case 2:c=value;return;
					}
				}
			}
		}
	19.分部类和分部方法
		partial
7.类和继承
	4.屏蔽基类的成员
		1.声明相同的名称的成员，类型也相同
		2.函数成员签名相同，返回类型可以不同
		3.使用 new 修饰符 可以去除编译警告
		4.可以屏蔽静态成员
	5.基类访问
		访问被隐藏的基类成员：关键字 base.+成员名称
	6.使用基类的引用
		基类：virtual
		派生类：override
		虚方法可以使基类的引用访问转至派生类内
	7.构造函数的执行
		class Driver
		{
			// 构造函数实际执行：public son():base()
			public son():this("param")
			{}
			public son(string param)
			{}
		}
		new Driver();
		构造函数执行顺序：父类->子类带参数->子类无参数；由外往内
	8.类的访问修饰符
		不同命名空间下的类的可访问性
		public：不同命名空间可直接访问
		internal：默认
			1.使用 using 引用命名空间
			1.直接使用命名空间：myNamespace.MyClass
	9.成员的访问修饰符
		public
		private
		protected
		internal
		internal protected
	11.抽象类 abstract
	12.密封类 sealed
		不能被继承
	13.静态类 static
		不能被继承
		所有成员（字段、方法和构造函数）都是静态的
		不能实例化
	14.扩展方法
		必须是静态的
		所在的类也是静态的
		第一个参数必须是： this+类名+x
		e.g
			class Calc{}
			static class Extend
			{
				public static void exFunc(this Calc c){}
			}
	x外部方法
19.泛型
	19.13　泛型的协变和逆变？
20.枚举数和迭代器
	1.枚举数和可枚举类型
		1.1　使用foreach语句
			obj.GetEnumerator(); 获取对象的枚举数
		1.2　枚举数类型
	2　使用IEnumerator接口
		Current 字段，返回当前位置元素
		MoveNext 方法，位置+1，新的位置无效返回 false
		Reset 重置位置为 -1
	3　IEnumerable接口
	4　不实现接口的枚举数
	5　泛型枚举接口
	6　IEnumerator接口
	7　IEnumerable接口
	8　迭代器
		8.1　迭代器块
		8.2　使用迭代器来创建枚举数
		8.3　使用迭代器来创建可枚举类型
	9　常见迭代器模式
	10　产生可枚举类型和枚举数
	11　产生多个可枚举类型
	12　产生多个枚举数
	13　迭代器实质
21.LINQ

补充
	类型转换
	字符串方法
	数组方法
	[]和 ArrayList
	日期 DateTime
		// 当前日期对象
		DateTime date = DateTime.Now;
		// 时间字符串
        DateTime date = DateTime.Parse("2018-05-15");
		DateTime.TryParse()
        // 时间戳
        DateTime date = DateTime.FromFileTime(45644646);
        // 只有年月日，时间为 0
		DateTime date = DateTime.Today
		输出格式
			
	Math
		namespace System
		{
		    // 为三角函数、对数函数和其他通用数学函数提供常数和静态方法。
		    public static class Math
		    {
		        // 表示自然对数的底，它由常数 e 指定。
		        public const double E = 2.71828;
		        // 表示圆的周长与其直径的比值，它通过常数 n 指定。
		        public const double PI = 3.14159;
		        // 返回结果: 绝对值 x，满足 0 ≤ x ≤System.xx.MaxValue。
		        public static <number> Abs(<number> value);
		        // 返回余弦值为指定数字的角度。
		        // 一个表示余弦值的数字，其中 -1 ≤d≤ 1。
		        // 角度 θ，以弧度为单位，满足 0 ≤θ≤π- 或 -如果 d < -1 或 d > 1，则为 System.Double.NaN。
		        public static double Acos(double d);
		        // 返回正弦值为指定数字的角度。
		        // 一个表示正弦值的数字，其中 -1 ≤d≤ 1。
		        // 角度 θ，以弧度为单位，满足 -π/2 ≤θ≤π/2- 或 -如果 d < -1 或 d > 1，则为 System.Double.NaN。
		        public static double Asin(double d);
		        // 返回正切值为指定数字的角度。
		        // 角度 θ，以弧度为单位，满足 -π/2 ≤θ≤π/2。- 或 -如果 d 等于 System.Double.NaN，则为 System.Double.NaN；如果
		        // d 等于 System.Double.NegativeInfinity，则为舍入为双精度值 (-1.5707963267949) 的 -π/2；或者如果
		        // d 等于 System.Double.PositiveInfinity，则为舍入为双精度值 (1.5707963267949) 的 π/2。
		        public static double Atan(double d);
		        // 返回正切值为两个指定数字的商的角度。
		        // 点的 y 坐标。
		        // 点的 x 坐标。
		        // 返回结果:
		        // 角度 θ，以弧度为单位，满足 -π≤θ≤π，且 tan(θ) = y / x，其中 (x, y) 是笛卡尔平面中的一个点。请看下面：如果 (x,
		        // y) 在第 1 象限，则 0 < θ < π/2。如果 (x, y) 在第 2 象限，则 π/2 < θ≤π。如果 (x, y) 在第 3 象限，则
		        // -π < θ < -π/2。如果 (x, y) 在第 4 象限，则 -π/2 < θ < 0。如果点在象限的边界上，则返回值如下：如果 y 为 0
		        // 并且 x 不为负值，则 θ = 0。如果 y 为 0 并且 x 为负值，则 θ = π。如果 y 为正值并且 x 为 0，则 θ = π/2。如果
		        // y 负值并且 x 为 0，则 θ = -π/2。
		        public static double Atan2(double y, double x);
		        // 生成两个 32 位数字的完整乘积。
		        //   a: 第一个乘数 System.Int32。
		        //   b: 第二个乘数 System.Int32。
		        // 返回结果: 包含指定数字乘积的 System.Int64。
		        public static long BigMul(int a, int b);
		        // 返回大于或等于指定的十进制数的最小整数值。
		        // 返回大于或等于 d 的最小整数值。请注意，此方法返回 <number>，而不是整数类型。
		        public static <number> Ceiling(<number> d);
		        // 返回指定角度的余弦值。
		        public static double Cos(double d);
		        // 返回指定角度的双曲余弦值。
		        public static double Cosh(double value);
		        // 计算两个 32 位有符号整数的商，并通过输出参数返回余数。
		        //   a/b:
		        //   result: 余数。
		        public static <number> DivRem(<number> a, <number> b, out <number> result);
		        // 返回 e 的指定次幂。
		        public static double Exp(double d);
		        // 返回小于或等于指定小数的最大整数。
		        public static <number> Floor(<number> d);
		        // 返回一指定数字被另一指定数字相除的余数。
		        public static double IEEERemainder(double x, double y);
		        // 返回指定数字的自然对数（底为 e）。
		        public static double Log(double d);
		        // 返回指定数字在使用指定底时的对数。
		        public static double Log(double a, double newBase);
		        // 返回指定数字以 10 为底的对数。
		        public static double Log10(double d);
		        // 返回两个数中较大的一个。
		        public static <number> Max(<number> val1, <number> val2);
		        // 返回两个数中较小的一个。
		        public static <number> Min(<number> val1, <number> val2);
		        // 返回指定数字的指定次幂。
		        // 数字 x 的 y 次幂。
		        public static double Pow(double x, double y);
		        // 将小数值舍入到最接近的整数值。
		        // 返回结果: 最接近参数 d 的整数。如果 d 的小数部分正好处于两个整数中间，其中一个整数为偶数，另一个整数为奇数，则返回偶数。请注意，此方法返回 传入参数类型，而不是整数类型。
		        public static <number> Round(<number> d);
		        // 将小数值按指定的小数位数舍入。
		        //   digits: 返回值中的小数位数。
		        public static <number> Round(<number> d, int digits);
		        // 将小数值舍入到最接近的整数。一个参数，指定当一个值正好处于另两个数中间时如何舍入这个值。
		        public static <number> Round(<number> d, MidpointRounding mode);
		        // 将小数值按指定的小数位数舍入。一个参数，指定当一个值正好处于另两个数中间时如何舍入这个值。
		        public static <number> Round(<number> value, int digits, MidpointRounding mode);
		        // 返回表示数字符号的值。
		        // 一个指示 value 的符号的数字，如下表所示。返回值含义-1value 小于零。0value 等于零。1value 大于零。
		        public static int Sign(<number> value);
		        // 返回指定角度的正弦值。
		        public static double Sin(double a);
		        // 返回指定角度的双曲正弦值。
		        public static double Sinh(double value);
		        // 返回指定数字的平方根。
		        public static double Sqrt(double d);
		        // 返回指定角度的正切值。
		        // 返回结果: a 的正切值。
		        public static double Tan(double a);
		        // 返回指定角度的双曲正切值。
		        // 返回结果: value 的双曲正切值。
		        public static double Tanh(double value);
		        // 计算指定小数的整数部分。
		        // d 的整数部分（即舍弃小数位后剩余的数）。
		        public static <number> Truncate(<number> d);
		    }
		}
	定时器
		System.Threading.Timer
			// state 作为 cb 的参数，null
			// dueTime 首次执行等待时间
			// period 等待时间，如果是 0，只执行一次 
			public Timer(cb, object state, int dueTime, int period);
	        public Timer(cb, object state, long dueTime, long period);
	        public Timer(cb, object state, TimeSpan dueTime, TimeSpan period);
	        public Timer((cb, object state, uint dueTime, uint period);
	        	Dispose() ： 销毁
	        	bool Change(int dueTime, int period): 修改
	DataTable
		添加引用
			using System.Data;
		创建表
			//创建一个空表
			DataTable dt = new DataTable();
			//创建一个名为"Table_New"的空表
			DataTable dt = new DataTable("Table_New");
		创建列
			//1.创建空列
			DataColumn dc = new DataColumn();
			dt.Columns.Add(dc);
			//2.创建带列名和类型名的列(两种方式任选其一)
			dt.Columns.Add("column0", System.Type.GetType("System.String"));
			dt.Columns.Add("column0", typeof(String));
			//3.通过列架构添加列
			DataColumn dc = new DataColumn("column1",System.Type.GetType("System.DateTime"));
			DataColumn dc = new DataColumn("column1", typeof(DateTime));
			dt.Columns.Add(dc);
		创建行
			//1.创建空行
			DataRow dr = dt.NewRow();
			dt.Rows.Add(dr);
			//2.创建空行
			dt.Rows.Add();
			//3.通过行框架创建并赋值
			//Add里面参数的数据顺序要和dt中的列的顺序对应 
			dt.Rows.Add("张三",DateTime.Now);
			//4.通过复制dt2表的某一行来创建
			dt.Rows.Add(dt2.Rows[i].ItemArray);
		赋值和取值
			//新建行的赋值
			DataRow dr = dt.NewRow();
			dr[0] = "张三";//通过索引赋值
			dr["column1"] = DateTime.Now; //通过名称赋值
			//对表已有行进行赋值
			dt.Rows[0][0] = "张三"; //通过索引赋值
			dt.Rows[0]["column1"] = DateTime.Now;//通过名称赋值
			//取值
			string name=dt.Rows[0][0].ToString();
			string time=dt.Rows[0]["column1"].ToString();
		筛选行
			//选择column1列值为空的行的集合
			DataRow[] drs = dt.Select("column1 is null");
			//选择column0列值为"李四"的行的集合
			DataRow[] drs = dt.Select("column0 = '李四'");
			//筛选column0列值中有"张"的行的集合(模糊查询)
			//如果的多条件筛选，可以加 and 或 or
			DataRow[] drs = dt.Select("column0 like '张%'");
			//筛选column0列值中有"张"的行的集合并按column1降序排序
			DataRow[] drs = dt.Select("column0 like '张%'", "column1 DESC");
		删除行
			//使用DataTable.Rows.Remove(DataRow)方法
			dt.Rows.Remove(dt.Rows[0]);
			//使用DataTable.Rows.RemoveAt(index)方法
			dt.Rows.RemoveAt(0);
			//使用DataRow.Delete()方法
			dt.Row[0].Delete();
			dt.AcceptChanges();
			//-----区别和注意点-----
			//Remove()和RemoveAt()方法是直接删除
			//Delete()方法只是将该行标记为deleted，但是还存在，还可DataTable.RejectChanges()回滚，使该行取消删除。
			//用Rows.Count来获取行数时，还是删除之前的行数，需要使用DataTable.AcceptChanges()方法来提交修改。
			//如果要删除DataTable中的多行，应该采用倒序循环DataTable.Rows，而且不能用foreach进行循环删除，因为正序删除时索引会发生变化，程式发生异常，很难预料后果。
			for (int i = dt.Rows.Count - 1; i >= 0; i--)
			{
			　　dt.Rows.RemoveAt(i);
			}
		复制表
			//复制表，同时复制了表结构和表中的数据
			DataTable dtNew = new DataTable();
			dtNew = dt.Copy();
			//复制表
			DataTable dtNew = dt.Copy();  //复制dt表数据结构
			dtNew.Clear()  //清空数据
			for (int i = 0; i < dt.Rows.Count; i++)
			{
			    if (条件语句)
			    {
			         dtNew.Rows.Add(dt.Rows[i].ItemArray);  //添加数据行
			    }
			}
			//克隆表，只是复制了表结构，不包括数据
			DataTable dtNew = new DataTable();
			dtNew = dt.Clone();
			//如果只需要某个表中的某一行
			DataTable dtNew = new DataTable();
			dtNew = dt.Copy();
			dtNew.Rows.Clear();//清空表数据
			dtNew.ImportRow(dt.Rows[0]);//这是加入的是第一行

	正则
		e.g
			using System.Text.RegularExpressions;
			Regex reg=new Regex("filter",RegexOptions.IgnoreCase);
			if (reg.IsMatch(str))
	        {}
	dll
	addIn
	Random 生成随机数
		Random rand = new Random();
		// 随机非负整数 [0,15)
		rand.Next(15);
		// 随机整数 [-5,10)
		rand.Next(-5,10);
		// 随机小数 [0.0,1.0)
		rand.NextDouble
	comboBox 
		属性：
			SelectedIndex：0
			SelectedItem：someStr
			SelectedText：
			SelectedValue：
	安装和部署
		1.新建项目
		2.其他...
		3.vs... Installer
		4.安装向导
		5.下一步，下一步...,完成
		6.双击->应用程序文件夹
		7."名称|类型"->空白处->右键->添加->文件->release/debug->全部文件
		8.为桌面|程序菜单添加快捷方式：
			1.右键->应用程序exe->创建快捷方式->剪切->至左侧目录
			2.双击->左侧目录->列表空白处->右键->创建快捷目录
		9.（避免安装目录名称不对）右键->应用程序文件夹->属性->{DefaultLocation->删除->[Manufacturer]=>"[ProgramFilesFolder]\[ProductName]"}
		10.解决方案资源管理器->右键->当前方案名称->属性->系统必备(p)...->选择必要的组件（默认已选好）
		11.设置公司、作者、图标、平台：解决方案资源管理器->取消自动隐藏->属性
		12.菜单栏->生成->生成解决方案->Debug/Release
winform
	System.Windows.Forms.DataGridView
		添加列
			
		创建行
			int index = this.dataGridView1.Rows.Add();
            this.dataGridView1.Rows[index].Cells[0].Value = "1";
            this.dataGridView1.Rows[index].Cells[1].Value = "2";
            this.dataGridView1.Rows[index].Cells[2].Value = "3";
		修改头部值
			this.dataGridView1.Columns[0].HeaderCell.Value = "字段1";
            this.dataGridView1.Columns[1].HeaderCell.Value = "字段2";
            this.dataGridView1.Columns[2].HeaderCell.Value = "字段3";